<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft ブロックエミュレーター (Y座標対応)</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            background-color: #f0f0f0;
        }

        #controls {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: center;
        }

        #controls label {
            margin-right: 5px;
            font-weight: bold;
        }

        #controls select,
        #controls input[type="number"] {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }

        #y-slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #y-slider {
            width: 150px;
        }

        #grid-container {
            display: grid;
            grid-template-columns: repeat(10, 30px); /* 10x10グリッドを想定 */
            grid-template-rows: repeat(10, 30px);
            border: 2px solid #333;
            width: 300px; /* 10 * 30px */
            height: 300px; /* 10 * 30px */
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            background-color: #eee;
        }

        .grid-cell {
            width: 30px;
            height: 30px;
            border: 1px solid #bbb;
            box-sizing: border-box; /* paddingとborderをwidth/heightに含める */
            background-color: #f9f9f9; /* デフォルトのセルの色 */
            cursor: pointer;
            transition: background-color 0.1s ease;
        }

        /* ブロックの種類に応じたスタイル */
        .grid-cell.dirt { background-color: #8B4513; } /* 茶色 */
        .grid-cell.grass_block { background-color: #7CFC00; } /* 緑 */
        .grid-cell.stone { background-color: #808080; } /* 灰色 */
        .grid-cell.oak_planks { background-color: #CD853F; } /* 薄茶色 */
        .grid-cell.air { background-color: #f9f9f9; } /* 空気（デフォルト） */

        #commands {
            margin-top: 20px;
            width: 80%;
            max-width: 600px;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #commands h3 {
            margin-top: 0;
            color: #333;
        }

        #fill-command {
            width: calc(100% - 20px);
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #e9e9e9;
            font-family: monospace;
            white-space: pre-wrap; /* 改行を有効にする */
            word-wrap: break-word; /* 長い単語を折り返す */
            min-height: 50px;
        }

        button {
            padding: 10px 20px;
            margin-top: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <h1>Minecraft ブロックエミュレーター</h1>

    <div id="controls">
        <label for="block-type">ブロックを選択:</label>
        <select id="block-type">
            <option value="air">空気 (消去)</option>
            <option value="dirt">土</option>
            <option value="grass_block">草ブロック</option>
            <option value="stone">石</option>
            <option value="oak_planks">オークの木材</option>
        </select>

        <div id="y-slider-container">
            <label for="current-y">現在のY座標:</label>
            <input type="range" id="y-slider" min="0" max="10" value="0">
            <input type="number" id="current-y" min="0" max="10" value="0">
        </div>

        <button onclick="generateFillCommand()">Fillコマンドを生成</button>
        <button onclick="resetGrid()">リセット</button>
    </div>

    <div id="grid-container">
        </div>

    <div id="commands">
        <h3>生成された /fill または /setblock コマンド:</h3>
        <pre id="fill-command"></pre>
        <button onclick="copyToClipboard()">コマンドをコピー</button>
    </div>

    <script>
        const GRID_2D_SIZE = 10; // 2Dグリッドのサイズ (X, Z軸)
        const MIN_Y = 0;       // 最小Y座標 (MinecraftのY座標に合わせる)
        const MAX_Y = 10;      // 最大Y座標 (ビルド可能な高さの範囲)

        const gridContainer = document.getElementById('grid-container');
        const blockTypeSelect = document.getElementById('block-type');
        const ySlider = document.getElementById('y-slider');
        const currentYInput = document.getElementById('current-y');
        const fillCommandOutput = document.getElementById('fill-command');

        // 全ブロックの状態を保存するMapオブジェクト
        // キーは "x,y,z" の文字列、値はブロックタイプ ('air'を含む)
        let blocks = new Map();
        let currentY = 0; // 現在表示・編集しているY座標

        // Y座標スライダー/入力の初期設定
        ySlider.min = MIN_Y;
        ySlider.max = MAX_Y;
        currentYInput.min = MIN_Y;
        currentYInput.max = MAX_Y;

        ySlider.value = currentY;
        currentYInput.value = currentY;

        // グリッドを初期化
        function initializeGrid() {
            gridContainer.innerHTML = ''; // 既存のセルをクリア
            // blocks.clear(); // Y座標リセット時に全てのブロックを消去する場合
            // 今回はリセットボタンでMap自体をクリア

            for (let z = 0; z < GRID_2D_SIZE; z++) { // Z軸 (グリッドの行)
                for (let x = 0; x < GRID_2D_SIZE; x++) { // X軸 (グリッドの列)
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    cell.dataset.x = x;
                    cell.dataset.z = z; // グリッドのYをMinecraftのZとして扱う
                    cell.addEventListener('click', placeBlock);
                    gridContainer.appendChild(cell);
                }
            }
            updateGridDisplay(); // 初回表示更新
        }

        // 現在のY座標に基づいてグリッドの表示を更新する
        function updateGridDisplay() {
            const cells = gridContainer.querySelectorAll('.grid-cell');
            cells.forEach(cell => {
                const x = parseInt(cell.dataset.x);
                const z = parseInt(cell.dataset.z);
                const blockKey = `${x},${currentY},${z}`;
                const blockType = blocks.has(blockKey) ? blocks.get(blockKey) : 'air';

                // 既存のブロッククラスを削除
                cell.className = 'grid-cell';
                // 新しいブロッククラスを追加
                cell.classList.add(blockType);
                cell.dataset.blockType = blockType; // Data属性も更新
            });
            fillCommandOutput.textContent = ''; // 表示Yが変わったらコマンドをクリア
        }

        // ブロックを配置する関数
        function placeBlock(event) {
            const cell = event.target;
            const selectedBlockType = blockTypeSelect.value;
            const x = parseInt(cell.dataset.x);
            const z = parseInt(cell.dataset.z); // グリッドのYはMinecraftのZ

            const blockKey = `${x},${currentY},${z}`;

            if (selectedBlockType === 'air') {
                blocks.delete(blockKey); // 空気の場合はMapから削除
            } else {
                blocks.set(blockKey, selectedBlockType); // ブロックタイプを保存
            }

            // セルの見た目を更新
            cell.className = 'grid-cell'; // 全てのクラスを削除
            cell.classList.add(selectedBlockType);
            cell.dataset.blockType = selectedBlockType; // Data属性も更新
        }

        // Y座標スライダー/入力変更時のイベントリスナー
        ySlider.addEventListener('input', (event) => {
            currentY = parseInt(event.target.value);
            currentYInput.value = currentY;
            updateGridDisplay();
        });

        currentYInput.addEventListener('change', (event) => {
            let val = parseInt(event.target.value);
            if (isNaN(val) || val < MIN_Y) val = MIN_Y;
            if (val > MAX_Y) val = MAX_Y;
            currentY = val;
            ySlider.value = currentY;
            currentYInput.value = currentY;
            updateGridDisplay();
        });


        // /fill コマンドを生成する関数
        function generateFillCommand() {
            const commands = [];
            
            // 全ての配置済みブロックを処理
            // Mapのキーからx, y, zをパース
            blocks.forEach((blockType, key) => {
                const parts = key.split(',');
                const x = parseInt(parts[0]);
                const y = parseInt(parts[1]);
                const z = parseInt(parts[2]);

                // Minecraftの座標系でコマンドを生成
                // ここでは、エミュレーターの(0,0,0)をMinecraftの(0,0,0)にマッピングすると仮定
                // 必要に応じてオフセットを追加できます (例: const mcX = x + 100;)
                const mcX = x;
                const mcY = y;
                const mcZ = z;

                commands.push(`/setblock ${mcX} ${mcY} ${mcZ} ${blockType}`);
            });

            if (commands.length === 0) {
                fillCommandOutput.textContent = "ブロックが配置されていません。";
            } else {
                fillCommandOutput.textContent = commands.join('\n');
            }
        }

        // グリッドとブロックデータをリセットする関数
        function resetGrid() {
            blocks.clear(); // 全てのブロックデータをクリア
            currentY = MIN_Y; // Y座標をリセット
            ySlider.value = currentY;
            currentYInput.value = currentY;
            initializeGrid(); // グリッドを再描画
            fillCommandOutput.textContent = '';
        }

        // クリップボードにコピーする関数
        function copyToClipboard() {
            const commandText = fillCommandOutput.textContent;
            if (commandText) {
                navigator.clipboard.writeText(commandText)
                    .then(() => alert('コマンドがクリップボードにコピーされました！'))
                    .catch(err => console.error('コピーに失敗しました:', err));
            } else {
                alert('コピーするコマンドがありません。');
            }
        }

        // ページロード時にグリッドを初期化
        window.onload = initializeGrid;
    </script>
</body>
</html>
